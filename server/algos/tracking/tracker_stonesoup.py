import numpy as np
import datetime
import glob, os
import cv2
from tqdm import tqdm
import stonesoup
from stonesoup.reader.generic import CSVDetectionReader
from stonesoup.feeder.time import TimeSyncFeeder
from stonesoup.models.transition.linear import (CombinedLinearGaussianTransitionModel,
                                                ConstantVelocity, RandomWalk)
from stonesoup.models.measurement.linear import LinearGaussian
from stonesoup.predictor.kalman import KalmanPredictor
from stonesoup.updater.kalman import KalmanUpdater
from stonesoup.hypothesiser.distance import DistanceHypothesiser
from stonesoup.measures import Mahalanobis
from stonesoup.dataassociator.neighbour import GNNWith2DAssignment
from stonesoup.types.state import GaussianState
from stonesoup.types.array import CovarianceMatrix, StateVector
from stonesoup.initiator.simple import MultiMeasurementInitiator
from stonesoup.deleter.time import UpdateTimeStepsDeleter
from stonesoup.tracker.simple import MultiTargetTracker

# detector = CSVDetectionReader(
#     p,
#     state_vector_fields=("x", "y", "r"),
#     time_field="time")



# detector = TimeSyncFeeder(detector, time_window=datetime.timedelta(seconds=1))

# t_models = [ConstantVelocity(200), ConstantVelocity(200), RandomWalk(20)]
# transition_model = CombinedLinearGaussianTransitionModel(t_models)


# measurement_model = LinearGaussian(ndim_state=5, mapping=[0, 2, 4],
#                                    noise_covar=np.diag([1**2, 1**2, 3**2]))


# predictor = KalmanPredictor(transition_model)


# updater = KalmanUpdater(measurement_model)


# hypothesiser = DistanceHypothesiser(predictor, updater, Mahalanobis(), 10)


# data_associator = GNNWith2DAssignment(hypothesiser)



# prior_state = GaussianState(StateVector(np.zeros((5,1))),
#                             CovarianceMatrix(np.diag([100**2, 30**2, 100**2, 30**2, 100**2])))
# deleter_init = UpdateTimeStepsDeleter(time_steps_since_update=2)
# initiator = MultiMeasurementInitiator(prior_state, deleter_init, data_associator, updater,
#                                       measurement_model, min_points=3)
# deleter = UpdateTimeStepsDeleter(time_steps_since_update=4)


# tracker = MultiTargetTracker(
#     initiator=initiator,
#     deleter=deleter,
#     detector=detector,
#     data_associator=data_associator,
#     updater=updater,
# )



def draw_detections(image, detections):
    """ Draw detections on an image

    Parameters
    ----------
    image: :class:`PIL.Image`
        Image on which to draw the detections
    detections: : set of :class:`~.Detection`
        A set of detections generated by :class:`~.TensorFlowBoxObjectDetector`

    Returns
    -------
    : :class:`PIL.Image`
        Image with detections drawn
    """
    kps = []
    for detection in detections:
        x, y, r = np.array(detection.state_vector).reshape(3)
        # x1, y1 = (x0 + w, y0 + h)
        # kp = cv2.KeyPoint(float(r['x']), float(r['y']), float(r['r']), class_id=int(r['id']))
        kp = cv2.KeyPoint(x, y, r)
        kps.append(kp)

    blank = np.zeros((1, 1))
    img_blobs = cv2.drawKeypoints(image, kps, blank, (0, 0, 255),
                            cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
    return img_blobs

def draw_tracks(image, tracks, id_dict, show_history=True):
    """ Draw tracks on an image

    """
    # global track_counter, id_dict
    for track in tracks:
        bboxes = np.array([np.array(state.state_vector[[0, 2, 4]]).reshape(3)
                           for state in track.states])

        if track.id not in id_dict:
            id_dict[track.id] = str(len(id_dict)+1)
            # track_counter += 1
        id = id_dict[track.id]

        x, y, r = bboxes[-1]
        image = cv2.circle(image, (int(x), int(y)), int(r), color=(255, 0, 0), thickness=2)
        cv2.putText(img=image, text=id, org=(int(x), int(y)), fontFace=cv2.FONT_HERSHEY_TRIPLEX, fontScale=3, color=(255, 0, 0),thickness=3)
        if show_history:
            pts = np.array([[int(box[0]), int(box[1])] for box in bboxes])
            pts = pts.reshape((-1, 1, 2))
            image = cv2.polylines(image, [pts], False, (255, 0, 0), 2)

    return image

def track(p):
    detector = CSVDetectionReader(
    os.path.join(p, 'dets.csv'),
    state_vector_fields=("x", "y", "r"),
    time_field="time")

    detector = TimeSyncFeeder(detector, time_window=datetime.timedelta(seconds=1))

    t_models = [ConstantVelocity(200), ConstantVelocity(200), RandomWalk(20)]
    transition_model = CombinedLinearGaussianTransitionModel(t_models)

    measurement_model = LinearGaussian(ndim_state=5, mapping=[0, 2, 4],
                                    noise_covar=np.diag([1**2, 1**2, 3**2]))

    predictor = KalmanPredictor(transition_model)

    updater = KalmanUpdater(measurement_model)

    hypothesiser = DistanceHypothesiser(predictor, updater, Mahalanobis(), 10)

    data_associator = GNNWith2DAssignment(hypothesiser)

    prior_state = GaussianState(StateVector(np.zeros((5,1))),
                                CovarianceMatrix(np.diag([100**2, 30**2, 100**2, 30**2, 100**2])))
    deleter_init = UpdateTimeStepsDeleter(time_steps_since_update=2)
    initiator = MultiMeasurementInitiator(prior_state, deleter_init, data_associator, updater,
                                        measurement_model, min_points=3)
    deleter = UpdateTimeStepsDeleter(time_steps_since_update=4)


    tracker = MultiTargetTracker(
        initiator=initiator,
        deleter=deleter,
        detector=detector,
        data_associator=data_associator,
        updater=updater,
    )

    paths = []
    for file in glob.glob(f"{p}/images/*.jpg"):
        paths.append(file)

    os.mkdir(f"{p}/tracks")
    # track_counter = 0
    id_dict = {}

    for (timestamp, tracks), img_path in tqdm(zip(tracker, paths)):
        # Read frame
        image = cv2.imread(img_path)

        # Read the detections
        detections = detector.detections

        # Plot output
        image = draw_detections(image, detections)
        image = draw_tracks(image, tracks, id_dict, show_history=False)
        name = img_path.split('\\')[-1][:-4] + '_with_tracks' + '.jpg'
        cv2.imwrite(f"{p}/tracks/{name}", image)
        # cv2.namedWindow('cur', cv2.WINDOW_KEEPRATIO)
        # cv2.imshow('cur', image)
        # cv2.waitKey(0)
        # cv2.destroyAllWindows()
        
